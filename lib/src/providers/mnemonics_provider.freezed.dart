// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'mnemonics_provider.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MnemonicsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MnemonicsStateCopyWith<$Res> {
  factory $MnemonicsStateCopyWith(
          MnemonicsState value, $Res Function(MnemonicsState) then) =
      _$MnemonicsStateCopyWithImpl<$Res, MnemonicsState>;
}

/// @nodoc
class _$MnemonicsStateCopyWithImpl<$Res, $Val extends MnemonicsState>
    implements $MnemonicsStateCopyWith<$Res> {
  _$MnemonicsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$MnemonicsStateGeneratingImplCopyWith<$Res> {
  factory _$$MnemonicsStateGeneratingImplCopyWith(
          _$MnemonicsStateGeneratingImpl value,
          $Res Function(_$MnemonicsStateGeneratingImpl) then) =
      __$$MnemonicsStateGeneratingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MnemonicsStateGeneratingImplCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateGeneratingImpl>
    implements _$$MnemonicsStateGeneratingImplCopyWith<$Res> {
  __$$MnemonicsStateGeneratingImplCopyWithImpl(
      _$MnemonicsStateGeneratingImpl _value,
      $Res Function(_$MnemonicsStateGeneratingImpl) _then)
      : super(_value, _then);

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MnemonicsStateGeneratingImpl implements MnemonicsStateGenerating {
  const _$MnemonicsStateGeneratingImpl();

  @override
  String toString() {
    return 'MnemonicsState.generating()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateGeneratingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return generating();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return generating?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (generating != null) {
      return generating();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return generating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return generating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (generating != null) {
      return generating(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateGenerating implements MnemonicsState {
  const factory MnemonicsStateGenerating() = _$MnemonicsStateGeneratingImpl;
}

/// @nodoc
abstract class _$$MnemonicsStateAppendingImplCopyWith<$Res> {
  factory _$$MnemonicsStateAppendingImplCopyWith(
          _$MnemonicsStateAppendingImpl value,
          $Res Function(_$MnemonicsStateAppendingImpl) then) =
      __$$MnemonicsStateAppendingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MnemonicsStateAppendingImplCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateAppendingImpl>
    implements _$$MnemonicsStateAppendingImplCopyWith<$Res> {
  __$$MnemonicsStateAppendingImplCopyWithImpl(
      _$MnemonicsStateAppendingImpl _value,
      $Res Function(_$MnemonicsStateAppendingImpl) _then)
      : super(_value, _then);

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MnemonicsStateAppendingImpl implements MnemonicsStateAppending {
  const _$MnemonicsStateAppendingImpl();

  @override
  String toString() {
    return 'MnemonicsState.appending()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateAppendingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return appending();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return appending?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (appending != null) {
      return appending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return appending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return appending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (appending != null) {
      return appending(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateAppending implements MnemonicsState {
  const factory MnemonicsStateAppending() = _$MnemonicsStateAppendingImpl;
}

/// @nodoc
abstract class _$$MnemonicsStateErrorImplCopyWith<$Res> {
  factory _$$MnemonicsStateErrorImplCopyWith(_$MnemonicsStateErrorImpl value,
          $Res Function(_$MnemonicsStateErrorImpl) then) =
      __$$MnemonicsStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$MnemonicsStateErrorImplCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateErrorImpl>
    implements _$$MnemonicsStateErrorImplCopyWith<$Res> {
  __$$MnemonicsStateErrorImplCopyWithImpl(_$MnemonicsStateErrorImpl _value,
      $Res Function(_$MnemonicsStateErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$MnemonicsStateErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MnemonicsStateErrorImpl implements MnemonicsStateError {
  const _$MnemonicsStateErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'MnemonicsState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MnemonicsStateErrorImplCopyWith<_$MnemonicsStateErrorImpl> get copyWith =>
      __$$MnemonicsStateErrorImplCopyWithImpl<_$MnemonicsStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateError implements MnemonicsState {
  const factory MnemonicsStateError(final String message) =
      _$MnemonicsStateErrorImpl;

  String get message;

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MnemonicsStateErrorImplCopyWith<_$MnemonicsStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MnemonicsStateLoadedImplCopyWith<$Res> {
  factory _$$MnemonicsStateLoadedImplCopyWith(_$MnemonicsStateLoadedImpl value,
          $Res Function(_$MnemonicsStateLoadedImpl) then) =
      __$$MnemonicsStateLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String mnemonic, String? traceId});
}

/// @nodoc
class __$$MnemonicsStateLoadedImplCopyWithImpl<$Res>
    extends _$MnemonicsStateCopyWithImpl<$Res, _$MnemonicsStateLoadedImpl>
    implements _$$MnemonicsStateLoadedImplCopyWith<$Res> {
  __$$MnemonicsStateLoadedImplCopyWithImpl(_$MnemonicsStateLoadedImpl _value,
      $Res Function(_$MnemonicsStateLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mnemonic = null,
    Object? traceId = freezed,
  }) {
    return _then(_$MnemonicsStateLoadedImpl(
      mnemonic: null == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as String,
      traceId: freezed == traceId
          ? _value.traceId
          : traceId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$MnemonicsStateLoadedImpl implements MnemonicsStateLoaded {
  const _$MnemonicsStateLoadedImpl(
      {required this.mnemonic, required this.traceId});

  @override
  final String mnemonic;
  @override
  final String? traceId;

  @override
  String toString() {
    return 'MnemonicsState.loaded(mnemonic: $mnemonic, traceId: $traceId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MnemonicsStateLoadedImpl &&
            (identical(other.mnemonic, mnemonic) ||
                other.mnemonic == mnemonic) &&
            (identical(other.traceId, traceId) || other.traceId == traceId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, mnemonic, traceId);

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MnemonicsStateLoadedImplCopyWith<_$MnemonicsStateLoadedImpl>
      get copyWith =>
          __$$MnemonicsStateLoadedImplCopyWithImpl<_$MnemonicsStateLoadedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() generating,
    required TResult Function() appending,
    required TResult Function(String message) error,
    required TResult Function(String mnemonic, String? traceId) loaded,
  }) {
    return loaded(mnemonic, traceId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? generating,
    TResult? Function()? appending,
    TResult? Function(String message)? error,
    TResult? Function(String mnemonic, String? traceId)? loaded,
  }) {
    return loaded?.call(mnemonic, traceId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? generating,
    TResult Function()? appending,
    TResult Function(String message)? error,
    TResult Function(String mnemonic, String? traceId)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(mnemonic, traceId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MnemonicsStateGenerating value) generating,
    required TResult Function(MnemonicsStateAppending value) appending,
    required TResult Function(MnemonicsStateError value) error,
    required TResult Function(MnemonicsStateLoaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MnemonicsStateGenerating value)? generating,
    TResult? Function(MnemonicsStateAppending value)? appending,
    TResult? Function(MnemonicsStateError value)? error,
    TResult? Function(MnemonicsStateLoaded value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MnemonicsStateGenerating value)? generating,
    TResult Function(MnemonicsStateAppending value)? appending,
    TResult Function(MnemonicsStateError value)? error,
    TResult Function(MnemonicsStateLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class MnemonicsStateLoaded implements MnemonicsState {
  const factory MnemonicsStateLoaded(
      {required final String mnemonic,
      required final String? traceId}) = _$MnemonicsStateLoadedImpl;

  String get mnemonic;
  String? get traceId;

  /// Create a copy of MnemonicsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MnemonicsStateLoadedImplCopyWith<_$MnemonicsStateLoadedImpl>
      get copyWith => throw _privateConstructorUsedError;
}
